# 将复杂的有状态应用程序迁移到无服务器平台的经验

# [Lessons Learned from Migrating Complex Stateful Applications onto Serverless Platforms](https://dl.acm.org/doi/10.1145/3476886.3477510)

## 介绍

* 无服务计算渐渐成为云计算主要范式，它具有前瞻性的简化平台开发的潜力，能沟帮助开发者从繁琐的冗余操作任务脱离。
* 无服务平台负责管理用户已经打包上传至平台的应用，这让开发者更专注于平台的逻辑执行无需关注底层的资源管理和部署。不止如此，随着用户需求量变化，无服务平台还会负责管理底层架构资源管理和伸缩部署用户的应用。这一特性受到了工业界和学术界的极大拥护。但是无服务平台暂时只适用于一些特定场景——无状态和并行执行
* 但是无服务器计算的使用仅限于少数表现为无状态和并行执行的应用场景，而且如果重新构建现有代码库去适应无服务计算需求，这会带来很多成本投入。
* 为了避免这种繁杂的重构原代码库，尽量减少代码修改的迁移策略可以作为一个新的研究方向，而本文将4个微服务平台迁移到无服务平台 (`Apache open Whisk`)，这个实验过程中的经验和结果观测能更好的帮助推动这一研究方向进展，其中有许多关于在迁移过程中减少修改代码和实际性能考虑的指导。这些工作内容能帮助提高无服务计算的高可用性和无服务平台的适用性。
* 迁移中的挑战
  * 迁移过程中尽可能减少代码修改
  * 迁移后的平台的性能表现应该与迁移前保持相似

## 论文作者
* Yinlong Xu：中国科技大学计算机科学与技术学院教授，研究领域：分布式存储，网络编码，组合优化算法，并行算法。
* Ruichuan Chen：贝尔实验室的杰出技术员（DMTS），研究领域：网络和分布式系统，目前的研究集中在云计算和机器学习系统。
* Cheng Li：中国科学技术大学计算机科学与技术学院特任研究员，主要研究方向：大规模、实时、高可用分布式系统。
* 其他第一作者 ：Zewen Jin  , Yiming Zhu , Jiaan Zhu  , Dongbo Yu 

## 背景和动机

### 微服务平台

* 一个典型的微服务应用由许多长期运行的微服务（多达数百甚至数千个）组成，涵盖计算、通信和存储功能。这些微服务是松耦合的，并通过定义好的`API`相互通信，因此每个微服务可以单独开发和运行。
* 每个微服务通常作为一个服务器运行。这种类型的部署排除了只有在需要时才执行服务，并可能导致应用开发者过度配置资源以满足工作负载的要求。这种过度配置导致基础设施运营商的资源利用率低，而应用开发者的开发成本高。此外，尽管微服务架构简化了每个微服务组件的开发和运行方式，但它要求开发者仔细监测和管理资源（如容器、虚拟机），以适当地扩展每个微服务，这使得为经常变化的工作负载提供服务具有挑战性。

### 无服务平台

* 无服务器计算范式的目的是让开发者不再管理资源，快速扩展到不同的工作负载，并通过现收现付的定价模式提供成本效益。无服务器计算最流行的实现方式是 "功能即服务" (`FaaS`)。
* 在`FaaS`平台中，开发者将他们的应用逻辑写成一组无状态函数。每个请求被派发到一个函数或一个函数序列，这将导致一个函数实例被安排在一个行动容器内运行，处理请求并产生输出。在函数执行完成后，其状态被销毁或通过存储或信息传递系统外部化；因此，释放出的资源可用于其他用途。这些机制结合在一起，使无服务器功能的执行通常是短暂的，并能在需要时对基础设施资源进行灵活、精细的调度和扩展，以满足不同的工作负载。这种灵活性反过来又为基础设施运营商带来了资源效率，为开发者带来了成本效率。
* 然而，无服务器功能的无状态性质在复杂的有状态应用和FaaS平台之间造成了一种根本性的矛盾。
* 为了充分利用无服务器计算，现有复杂应用的开发者必须重新架构他们的应用，这样做成本很高，而且有些临时性，因此最好是最大限度地重用现有代码库。因此，有一种原则性的方法可以将现有的应用程序迁移到无服务器平台上，并使代码的改动最小，性能（如延迟）相当，这是非常有意义的。

## 迁移的工作内容

* 无服务平台
  * `Apache OpenWhisk`
  
* 微服务平台
  * `Overleaf` (基于云的LaTex编辑平台)
  * `Social Network` (社交网络平台)
  * `LAB Insurance Sales Portal` (电子商务平台)
  * `Robot Shop` (电子商务平台)

* 被迁移的平台由12-26个微服务组件组成，其中包括应用逻辑组件，以及通常用于通信（如`Kafka`和`RabbitMQ`）、保持应用状态（如`Redis`和`MongoDB`）或监控应用状态（如`Zipkin`和`Jaeger`）的现成的软件组件。为了尽量减少对原始应用架构的改变，不会迁移这些现成的组件；或者，这些组件可以用无服务器平台提供的对应组件来代替（例如，`AWS S3`用于保持应用状态）。此外，由于无服务器功能是短暂的，不能直接在网络上寻址，如果微服务组件以双向流的方式与其他实体互动，例如通过`websocket`或流式`RPC`，我们就保持其不变。

  ![微服务组件.png](https://i.loli.net/2021/09/27/hM2IQUpGabrj4w8.png)
###  Overleaf

`Overleaf`是一个实时协作的`LaTeX`编辑器。除了现成的组件（如`NginX`、`MongoDB`和`Redis`），它还有12个应用逻辑微服务，都是用`JavaScript`编写的在`Node.js`运行。这些微服务使用`RESTful APIs`和`Redis Pub/Sub`通道相互通信，`MongoDB`被用于数据存储。`Overleaf`利用`Express`框架，它允许微服务中的内部服务模块暴露给其他微服务。

#### 迁移

* 如表2所示，我们为`Overleaf`引入了1.2%的代码行变化。首先，12个应用逻辑组件中的8个是无状态的，并通过`RESTful APIs`进行通信，使它们的迁移变得简单明了：我们为每个组件增加了一个包装函数，作为`OpenWhisk`所需的入口。这个包装器负责在调用时将参数转发给原始的`Express`处理程序。

* 此外，还有4个有状态的微服务组件。
	* #1 `Web`微服务作为发送请求到下游微服务的调度器，作为请求认证器，读取本地存储的凭证以验证请求，也作为文件上传/下载的代理服务器。
		* 迁移修改：论文中分离了它的认证模块，将认证相关的凭证持久化在`Redis`中，并保留了原始微服务中的文件代理服务器模块。
	* #2 `clsi`微服务编译`LaTeX`文件并在本地存储输出。这个本地存储作为一个文件服务器，用于文件的检索。
	  * 迁移修改：修改了38行代码，将生成的文件存储在`filetore`中
	* #3 `filestore`微服务负责提供Overleaf文件。（不做修改）
	* #4 实时微服务向客户暴露可寻址的网络接口，接受传入的连接并通过连接与客户进行交互。（不做修改）

#### 经验与指导——状态管理

* 无服务器函数通常是无状态的，而且生命周期短的，目的是为了使它们易于管理和扩展。对同一个无服务器函数的多个请求可能会被引导到不同的函数实例上执行，因此，一次执行产生的状态可能无法被下一次执行所访问。然而，这种方法使许多微服务应用所需的状态管理变得复杂。为了在同一功能的多个实例之间或在多个功能之间共享状态，一种常见的方法是将状态外部化到一些中介件（例如`MongoDB`、`Redis`或`AWS S3`等存储系统），以便共享状态。如果应用程序使用现成的存储组件（如`MongoDB`），可以简单地保留这些组件以尽量减少代码更改，或者修改应用程序以使用无服务器平台提供的存储服务（如`AWS S3`），所以该文将那些归类为现有的组件不再修改。
* 如果状态被存储在本地的定制微服务组件内，我们必须在外部化之前手动识别应用程序的状态。例如，在`Overleaf`中有两种类型的本地状态。一种是用于`Web`微服务中认证的`csrf` `tokens`。另一个是`clsi`服务中的编译文件，迁移后存储在`filestore`中。这些数据在我们迁移后被存储在`Redis`中。


### Social Network

`Social Network`是一个基于`DeathStarBench`的在线社交网络应用，`DeathStarBench`曾被用作云微服务的基准套件。这个应用使用`Apache Thrift`来实现用`C++`和`Lua`编写的微服务之间的`RPC`通信。

####  迁移

`Social Net-work`中的所有应用逻辑微服务都是无状态的，这里可以将它们全部迁移。本论文面临的关键挑战是，`Apache OpenWhisk`的功能是通过`HTTP`请求调用的，输入的是`JSON`编码的数据，而社交网络的RPC代码使用的是低级别的套接字`API`。因此，我们必须将其原始的`RPC`通信转换为`HTTP`通信，并实现额外的`JSON`序列化/反序列化功能。为了协助这一转换，本文开发了一个半自动的脚本，大约有700行`Python`代码。关于请求路由逻辑，我们绕过了原来的RPC监听器。

#### 经验指导——监听（Listening）和路由（Routing）

无论在通信中选择什么样的同步性，相互作用的微服务组件必须监听新的请求，并将它们路由到相关的内部处理程序。通过`RESTful APIs`和`RPCs`，微服务通常暴露一个网络端口，并通过该端口接受请求。通过消息代理（如`Kafka`、`RabbitMQ`、`Redis` `Pub/Sub`），微服务订阅了一个主题或通道，并等待传入的请求。

在无服务器计算的背景下，这种用于接收消息的脚手架代码变得没有必要，因为功能之间的消息交换是由无服务器平台处理的。在以最小的代码改动为目标的迁移工作中，需要对这种输入进行适当的转换，以便将请求分派给相应的处理程序。有两种方法可以采取。

##### 保留监听

这种方法会在无服务器函数中保留微服务组件的原始监听器。为了处理请求，需要重新编写一些附着（glue）代码，以便将无服务器平台上传入的`HTTP`请求转换为微服务组件所接受的请求格式。例如，如果最初的微服务组件有一个`RPC`服务器，那么附着（glue）代码就必须在无服务器功能中把`HTTP`请求转换成`RPC`。这种方法可以极大地减少迁移的工作量。例如，在`Overleaf`中，我们只需要写66行`JavaScript`附着代码来包装现有的监听器，然后将其应用到10个微服务组件中。一个潜在的缺点是附着代码所带来的额外延迟。

##### 绕过监听

这种方法将删除或绕过原来的监听器。它的效率更高，但它需要前人的努力，为每种类型的请求找到并调用适当的内部处理程序。在基于RPC的微服务中，RPC存根和处理程序代码的解耦使迁移变得相当直接。相比之下，在使用REST API的微服务中，处理程序和监听器的代码更加紧密耦合，例如，由于底层框架（例如，`JavaScript`的`Express`和`Python`的`Flask`）。这种迁移需要更多的努力和改变，使其更加繁琐和容易出错。例如，使用`Express`框架编写的`Overleaf`的`Spelling`组件需要修改大约150行代码，尽管该微服务本身只由800行代码组成。对于像`web`这样由大约4万行代码组成的大型微服务，这种修改需要更多的修改。

### LAB Insurance Sales Portal

`LAB`是一个使用`Micronaut`微服务框架的电子商务应用。它的微服务是用`Java`和`Kotlin`编写的，并依赖于`Micronaut`库。服务间的通信通过`RESTful APIs`或`Apache Kafka`消息代理进行。

#### 迁移

`LAB`有6个无状态的应用逻辑微副组件。这些组件最初与`RESTful APIs`和`Kafka`通信，因此我们做了必要的修改，使它们的**通信**适应`OpenWhisk`所需的特征，并完全删除了`Kafka`。对于剩下的4个有状态的组件，它们每个都运行一个本地的H2内存数据库来管理状态, 所以将这些H2数据库统一为一个新的有状态组件，这一改变使我们能够将这4个组件也迁移到无服务器中。

#### 经验指导——通信

* 微服务组件通过明确定义的接口相互通信。根据应用的需要，这种通信可以同步进行，也可以异步进行。在异步通信中，消息的发送者并不等待来自接收者的响应。这方面的例子包括通过消息中介和异步RPC的通信。在无服务器计算的背景下，通过阻塞的无服务器功能调用来应用同步通信，但这可能会导致效率低下和重复计费。因此，由于通信模式的转换，通过同步通道进行通信的微服务需要更多的改变才能从无服务器计算中获益。该论文把这些探索留给未来的工作。
* 无服务器功能之间的通信通常发生在异步通道中，迁移由异步通道交换消息的微服务组件（如消息代理）可以通过各种方式进行修改。
  * 发布时调用

    ![异步通信a.png](https://i.loli.net/2021/09/27/MdCE7S6WP1Gon4t.png)

    ![异步通信b.png](https://i.loli.net/2021/09/27/l1PwVLNbifZ4TA5.png)

    * 由于无服务器函数只有在有请求时才会被触发，如图a，所以不能简单地将作为消息接收者的微服务组件（以订阅者模式工作）用于有请求时执行的无服务器函数中。因此，发送者（即发布者）必须异步地调用无服务器功能（如图b），这样才能接收和处理消息。

  * 调用而不发布。

    ![异步通信c.png](https://i.loli.net/2021/09/27/mcwrtpi6joMS71b.png)

    * 发送者也可以用请求消息调用接收者函数（见图2c）。这种方法的优点是消除了发布和接收消息代理所带来的开销。此外，它使消息代理变得多余，因此可以删除它以简化应用程序的架构。另一方面，消息代理提供的功能，如消息排序或多用户并行支持，将丢失并必须以其他方式提供。例如，发送者可能需要调用多个订阅函数来实现并行性。

### Robot Shop

`Robot Shop`使用了几种流行的编程语言，包括`Node.js`、`Java`、`PHP`、`Python`和`Golang`，以及`Express`、`Flask`和`Spark`等网络框架。它的微服务通过`RESTful APIs`和`RabbitMQ`相互通信。

#### 迁移

它的所有应用逻辑微服务都是无状态的，它们的迁移与之前描述的`Overleaf`应用程序的迁移相似。保留了原来的监听器来转发请求，并增加了请求编码/解码的步骤。我们的大部分努力都集中于在此应用程序中使用的不同语言和框架中进行这种转换。

* 删除了`RabbitMQ`组件，该组件最初用于异步触发一些用户服务（即调度），因为其功能已经被`OpenWhisk`所支持。
* 删除了`RabbitMQ`组件，该组件最初用于异步触发一些用户服务（即调度），因为其功能已经被`OpenWhisk`所支持。

综上所述，虽然`Robot Shop`的代码库是最小的，但代码修改的比例（35.1%）是所有四个应用程序迁移中最高的。

## 实验评估

* 实验一：每个应用程序中一个任务的请求处理。`Overleaf`中的 "`Compile`"、`Social Network`中的 "`StorePost` "、`Robot Shop`中的 "`SubmitOrder`"
* 实验二：增加`Overleaf`的 "`Compile` "任务和`Robot Shop`的 "`SubmitOrder` "任务的负载，以评估`OpenWhisk`提供的可扩展性，并报告吞吐量和延迟值。我们使用`Locust`进行负载生成。
* 实验环境：
  * 一个虚拟机：40个2.2GHz vCPUs、40GB RAM和250GB SSD；承载了OpenWhisk的安装，有一个`controller`，一个`invoker`和一个无限的容器池大小，以及没有被迁移的微服务组件。这些组件在独立的容器中运行，没有再源限制。
  * 所有的无服务器功能都在`OpenWhisk`中以256MB的内存部署。
  * 为了与始终部署的微服务组件进行公平的比较，我们确保`OpenWhisk`功能是在温暖的容器中运行。论文中为什么要这么处理，是因为在稳定的工作负载下，功能容器将是温暖的，以更好地服务请求。其次，减少冷启动和调用延迟是一个活跃的研究课题，与本工作正交。

### 实验一

图中列出了应用中三个任务的请求的延迟细度。可以看出，无服务器（SL）和微服务（MS）部署的 "`compute` "步骤大致相同。原因是，对于计算，`OpenWhisk`函数和原始微服务容器都没有资源限制。

![实验一.png](https://i.loli.net/2021/09/27/LYaAVqFZWuRmHtn.png)

* 在无服务器功能中，有一个共同的 "`invocation` "开销。这种开销是由于`OpenWhisk`处理`HTTP`请求以触发函数的执行，在到达函数之前必须经过多个平台组件（即`NginX`、`controller`、`Kafka`和`invoker`）。另一方面，对于原始的微服务部署，请求直接通过社交网络的`Thrift RPC`和`Overleaf`和`Robot Shop`的`RESTful API`发生。
* 在无服务器部署中，还有两个步骤会产生开销。`Overleaf中` "`Compile`"任务的 "`Store`"步骤是由于我们与迁移有关的变化：我们没有将生成的文件保存在微服务组件中，而是将这些文件发送到文件存储组件中（`Overleaf`中`#3`的`filestore`）。这种将状态外化到存储服务的做法在无状态的服务器功能中很常见，只有通过提供对这种存储的快速访问才能缓解。
* `Social Network`的 "`StorePost `"任务中的 "`Init`"步骤涉及面更广。这一步指的是加载无服务器函数的可执行文件，以及在原始微服务组件中设置与`MongoDB`和`Memcached`的活跃数据库连接。首先，`OpenWhisk`的运行器和函数之间存在语言不匹配，即`OpenWhisk`的运行器使用`Python`来监听新请求，但 "`StorePost `"函数是用`C/C++`编写的。因此，`Python`运行器在每次请求时动态加载可执行的二进制文件。
* 由于数据库连接是在二进制文件中建立的，如果将这些连接请求移到函数处理程序之外，使它们只在行动容器启动时建立一次，但是因为数据库连接是在二进制文件中建立的，这种延迟不能轻易地被取消。

### 实验二

为了展示无服务器计算的自动扩展优势，对`Overleaf`的 "`Compile`"任务和`Robot Shop`的 "`SubmitOrder` "任务进行了实验，分别通过每秒增加5个和10个客户端来增加工作负载，直至系统饱和。

![compileOfOverleaf.png](https://i.loli.net/2021/09/27/wFr4zYUsSA6oJLg.png)

* 上图a显示，无服务器版本的 "`Compile` "任务支持每秒80个请求和60个客户端，而原来的微服务组件只能处理40个客户端和每秒19.3个请求。回顾一下，原始的微服务组件在运行时没有资源限制；然而，负责编译的`clsi` 组件却因其运行的单一进程而陷入瓶颈。另一方面，尽管`OpenWhisk`运行被限制在256MB内存，但它们仍然可以随着并发请求而扩展。

  ![SubmitOrder.png](https://i.loli.net/2021/09/27/yNQ1JB28DUsSkad.png)

* 上图是`Robot Shop`中的 "`SubmitOrder` "任务，图b显示了在这些工作负载下所经历的延时。随着负载的增加，原始的微服务经历了越来越多的延迟，在峰值负载下达到约2秒。相比之下，无服务器功能产生的延迟更加稳定，在峰值负载下约为900ms。如图a和b所示，观察到`Robot Shop`中的 "`SubmitOrder` "任务有类似的性能趋势，验证了无服务器平台的自动扩展能力。

## 展望和未来

无服务器计算可以使各种复杂的、有状态的应用受益。但是仍有一些公开的挑战需要解决。

* 可见的调用延迟可能会阻碍无服务器计算的采用，尤其是对延迟敏感的应用。在执行复杂应用逻辑所要求的一系列功能时，额外的延迟会被放大。因此，迁移方法应包含对延迟和无服务器优势（如自动扩展）的权衡，以避免 "过度迁移"。
* 如果有一种工具能够帮助开发者将其传统的微服务应用迁移到无服务器环境中，或者能够自动完成这种迁移，那么对于实现无服务器应用的优势将有极大的帮助。这样的工具也将加速无服务器计算在更多平台中的应用。
* 状态管理在将有状态的微服务迁移到无服务器平台上时起着关键作用。为了降低迁移的复杂性，状态管理系统应该有明确的接口，涵盖各种类型的状态（如文件、内存、键值对）。此外，快速的状态访问可能会提高迁移后无服务器功能的性能。

## 总结和思考

本论文对于细粒度的功能，如在`Overleaf`中的 "`Compile`"、`Social Network`中的 "`StorePost` "、`Robot Shop`中的 "`SubmitOrder`"的一个任务请求处理，无服务平台的延迟较高，而在后面测试自动扩展时，随着工作负载和客户请求的增加反而延迟和吞吐量效果都比微服务上的表现更好。如果仔细放大图片，实验二中`Overleaf`的`compile`任务的time 0s时无服务的延迟比微服务的延迟更高。

![overleaflatency.png](https://i.loli.net/2021/09/27/ejiJqPMl85bzxS9.png)

而在`Robot Shop`的'`SubmitOrder`’的time 0s 时却仍然与实验一“矛盾”

<img src="https://i.loli.net/2021/09/27/8l45YbBVWjLwnQh.png" alt="robotshopLatency.png" style="zoom: 50%;" /> 

这是因为在`Robot Shop`的'`SubmitOrder`’中起步的客户端请求为100；而`Overleaf`的`compile`中起步的客户端请求为40。

这里作者没有具体和实验一结合说明对比，但他在文中有这么一句话：

> 请注意，我们进行初步评估的目的不是为了展示我们向无服务器迁移的性能比微服务更好，而是应该被视为对我们的变化进行的 "理智检查"。

* 无服务的冷启动和延迟相关研究可以多去了解些。
* 无服务平台随需求的更改能自动伸缩，这点优势能带来更好的性能，但是在低负载量情况下，无服务器在延迟方面表现的性能更差。而本论文并不是为了讨论孰好孰坏，只是为无服务应用适用性增添了个新方案以及性能上与原平台相似且利用了无服务的自动伸缩的特性。所以在这基础上，是不是可以在多个细粒度进行比较和测试，更多维度去探究如何让其他平台更好地使用无服务计算。
* 文中提到的在同步通信时无服务平台并没有更好的优化方案，在这方面是不是可以扩展研究下。
* 无服务主要特性之一是无状态，然而大多数平台却需要状态管理；而且现有的状态管理在无服务平台增加都会产生一些延迟，比如本论文的`Overleaf`的`Store`部分，在低负载情况下，延迟比原有的微服务平台延迟更高。
